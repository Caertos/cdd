<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: hooks/useControls.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: hooks/useControls.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React from "react";
import { useContainerActions } from "./creation/useContainerActions";
import { useContainerCreation } from "./creation/useContainerCreation";
import { useLogsViewer } from "./creation/useLogsViewer";
import { useInput, useApp } from "ink";
import { getLogsStream } from "../helpers/dockerService/serviceComponents/containerLogs.js";
import { EXIT_DELAY } from "../helpers/constants.js";
import { createContainer as svcCreateContainer } from "../helpers/dockerService/serviceComponents/containerActions.js";
import { logger } from "../helpers/logger.js";

// Principal hook to manage user inputs and control the app state
/**
 * Main hook that wires user input, creation, actions and logs viewing.
 * It coordinates the modular hooks and exposes a compact API consumed by the App.
 *
 * @param {Array&lt;Object>} containers - Current list of Docker containers
 * @returns {Object} controls - API for the App component
 * @property {number} selected - Index of the currently selected container
 * @property {function} setSelected - Setter for selected index
 * @property {string} message - Current feedback message (creation or actions)
 * @property {string} messageColor - Color to show for the feedback message
 * @property {boolean} showLogs - Whether the logs viewer is active
 * @property {Array&lt;string>} logs - Array of log lines currently collected
 * @property {function} exitLogs - Helper to close the logs viewer
 * @property {boolean} creatingContainer - Whether the create-container prompt is open
 * @property {number} creationStep - Current step in the creation flow
 * @property {string} imageNameInput - Current value of the image name field
 * @property {string} containerNameInput - Current value of the container name field
 * @property {string} portInput - Current value of the port input field
 * @property {string} envInput - Current value of the env input field
 * @property {Object} creation - The creation hook API (setters and helpers)
 * @property {Object} actions - The actions hook API (helpers to start/stop/remove)
 * @property {Object} logsViewer - The logs viewer hook API
 * @property {boolean} showDebugLogs - Whether the debug log panel is visible
 * @property {Array&lt;string>} debugLogs - Buffered log lines captured from the shared logger
 * @property {boolean} confirmErase - Whether the erase confirmation dialog is active
 */
export function useControls(containers = []) {
  const [selected, setSelected] = React.useState(0);
  const [creatingContainer, setCreatingContainer] = React.useState(false);
  const [confirmErase, setConfirmErase] = React.useState(false);
  const [showDebugLogs, setShowDebugLogs] = React.useState(false);
  const [debugLogs, setDebugLogs] = React.useState([]);
  const total = containers.length;
  const { exit } = useApp();

  // Modular hooks
  const actions = useContainerActions({ containers });
  const creation = useContainerCreation({
    onCreate: async ({ imageName, containerName, portInput, envInput }) => {
      // Build Docker options
      const env = (envInput || "").split(",").map(s => s.trim()).filter(Boolean);
      const ports = (portInput || "").split(",").map(s => s.trim()).filter(Boolean);
      const ExposedPorts = {};
      const PortBindings = {};
      ports.forEach(pair => {
        const [host, cont] = pair.split(":");
        if (!host || !cont) return;
        const key = `${cont}/tcp`;
        ExposedPorts[key] = {};
        PortBindings[key] = PortBindings[key] || [];
        PortBindings[key].push({ HostPort: `${host}` });
      });

      const options = {
        Tty: true,
      };
      if (Object.keys(ExposedPorts).length) options.ExposedPorts = ExposedPorts;
      if (Object.keys(PortBindings).length) options.HostConfig = { PortBindings };
      if (env.length) options.Env = env;
    if (containerName) options.name = containerName;

    actions.setMessage(`Creating container ${imageName}...`);
    actions.setMessageColor("yellow");
      try {
        const id = await svcCreateContainer(imageName, options);
        actions.setMessage(`Created container ${id}`);
        actions.setMessageColor("green");
      } catch (err) {
        actions.setMessage(`Error creating container: ${err.message}`);
        actions.setMessageColor("red");
      } finally {
        setCreatingContainer(false);
      }
    },
    onCancel: () => setCreatingContainer(false),
    dbImages: ["mysql", "mariadb", "postgres", "mongo", "mssql", "redis"]
  });
  const logsViewer = useLogsViewer();

  // Handler to exit logs (delegated to logsViewer)
  const exitLogs = logsViewer.closeLogs;

  /**
   * Pipe container logs into the viewer while applying a hard limit.
   * @param {string} containerId - Container identifier used by Docker.
   */
  const startLogsStream = React.useCallback((containerId) => {
    getLogsStream(
      containerId,
      (data) => logsViewer.setLogs((prev) => {
        const newLogs = [...prev, ...data.split("\n").filter(Boolean)];
        return newLogs.slice(-1000);
      }),
      () => {},
      (err) => logsViewer.setLogs((prev) => [...prev, `Error: ${err.message}`])
    );
  }, [logsViewer]);

  /**
   * Manage the erase confirmation short-circuit flow.
   */
  const processEraseConfirmation = React.useCallback((input, key) => {
    if (input === "y" || input === "Y") {
      actions.handleAction({
        actionFn: async (id) => await actions.removeContainer(id),
        actionLabel: "Erasing",
        selected,
      });
      setConfirmErase(false);
      actions.setMessageColor("yellow");
      return;
    }

    if (input === "n" || input === "N" || key.escape) {
      setConfirmErase(false);
      actions.setMessage("");
      actions.setMessageColor("");
      return;
    }

    actions.setMessage("Are you sure you want to erase this container? (y/n)");
    actions.setMessageColor("yellow");
  }, [actions, selected]);

  /**
   * Handle inputs while the logs viewer is active.
   */
  const processLogsInput = React.useCallback((input, key) => {
    if (input === "q" || key.escape) {
      logsViewer.closeLogs();
    }
  }, [logsViewer]);

  /**
   * Route keystrokes to the container creation wizard.
   */
  const processCreationInput = React.useCallback((input, key) => {
    const step = creation.step;

    const removeLastChar = (setter) => setter((value) => (value || "").slice(0, -1));
    const appendChar = (setter, current, ch) => setter((current || "") + ch);

    if (key.escape) {
      creation.cancelCreation();
      setCreatingContainer(false);
      return;
    }

    if (input === "\r" || input === "\n") {
      creation.nextStep();
      return;
    }

    if (key.backspace || key.delete) {
      if (step === 0) removeLastChar(creation.setImageName);
      if (step === 1) removeLastChar(creation.setContainerName);
      if (step === 2) removeLastChar(creation.setPortInput);
      if (step === 3) removeLastChar(creation.setEnvInput);
      return;
    }

    if (input &amp;&amp; input.length === 1 &amp;&amp; !key.ctrl &amp;&amp; !key.meta) {
      if (step === 0) appendChar(creation.setImageName, creation.imageName, input);
      if (step === 1) appendChar(creation.setContainerName, creation.containerName, input);
      if (step === 2) appendChar(creation.setPortInput, creation.portInput, input);
      if (step === 3) appendChar(creation.setEnvInput, creation.envInput, input);
    }
  }, [creation, setCreatingContainer]);

  /**
   * Navigate the container list using arrow keys.
   * @returns {boolean} True when the input was consumed.
   */
  const handleNavigation = React.useCallback((input, key) => {
    if (total === 0) {
      return false;
    }

    if (key.upArrow) {
      setSelected((i) => (i === 0 ? total - 1 : i - 1));
      return true;
    }

    if (key.downArrow) {
      setSelected((i) => (i === total - 1 ? 0 : i + 1));
      return true;
    }

    return false;
  }, [total]);

  /**
   * Handle the quit command.
   * @returns {boolean} True when the input was consumed.
   */
  const handleExitCommand = React.useCallback((input) => {
    if (input !== "q") {
      return false;
    }

    actions.setMessage("Exiting...");
    actions.setMessageColor("yellow");
    logsViewer.closeLogs();
    setShowDebugLogs(false);

    const clearTerminal = () => {
      try {
        if (process.stdout &amp;&amp; process.stdout.isTTY) {
          process.stdout.write("\u001Bc");
        } else {
          console.clear();
        }
      } catch (err) {
        // Ignore clear errors to avoid blocking exit.
      }
    };

    setTimeout(() => {
      clearTerminal();
      exit();
      if (process.env.NODE_ENV !== "test") {
        setTimeout(() => process.exit(0), 50);
      }
    }, EXIT_DELAY);
    return true;
  }, [actions, exit, logsViewer]);

  /**
   * Execute Docker-related commands and prompt transitions.
   * @returns {boolean} True when the input was consumed.
   */
  const handleDockerCommands = React.useCallback((input) => {
    const container = containers[selected];

    if (input === "i") {
      actions.handleAction({
        actionFn: async (id) => await actions.startContainer(id),
        actionLabel: "Starting",
        selected,
        stateCheck: (c) => (c.state === "running" || c.status === "running") &amp;&amp; "Container is already running."
      });
      return true;
    }

    if (input === "p") {
      actions.handleAction({
        actionFn: async (id) => await actions.stopContainer(id),
        actionLabel: "Stopping",
        selected,
        stateCheck: (c) => (c.state === "exited" || c.status === "exited" || c.state === "stopped" || c.status === "stopped") &amp;&amp; "Container is already stopped."
      });
      return true;
    }

    if (input === "r") {
      actions.handleAction({
        actionFn: async (id) => await actions.restartContainer(id),
        actionLabel: "Restarting",
        selected,
      });
      return true;
    }

    if (input === "e") {
      if (!container) {
        return true;
      }

      setConfirmErase(true);
      actions.setMessage("Are you sure you want to erase this container? (y/n)");
      actions.setMessageColor("yellow");
      return true;
    }

    if (input === "l") {
      if (!container) {
        return true;
      }

      logsViewer.openLogs();
      startLogsStream(container.id);
      return true;
    }

    if (input === "c") {
      setCreatingContainer(true);
      creation.setStep(0);
      creation.setImageName("");
      creation.setContainerName("");
      creation.setPortInput("");
      creation.setEnvInput("");
      creation.setMessage("Insert the name of the image to create: ");
      creation.setMessageColor("yellow");
      return true;
    }

    if (input === "d") {
      setShowDebugLogs((prev) => !prev);
      return true;
    }

    return false;
  }, [actions, containers, creation, logsViewer, selected, setConfirmErase, setCreatingContainer, startLogsStream, setShowDebugLogs]);

  /**
   * Default handler executed when no special mode is active.
   */
  const processGlobalInput = React.useCallback((input, key) => {
    if (handleNavigation(input, key)) {
      return;
    }

    if (handleExitCommand(input)) {
      return;
    }

    handleDockerCommands(input);
  }, [handleDockerCommands, handleExitCommand, handleNavigation]);

  useInput((input, key) => {
    if (confirmErase) {
      processEraseConfirmation(input, key);
      return;
    }

    if (logsViewer.showLogs) {
      processLogsInput(input, key);
      return;
    }

    if (creatingContainer) {
      processCreationInput(input, key);
      return;
    }

    if (showDebugLogs &amp;&amp; key.escape) {
      setShowDebugLogs(false);
      return;
    }

    processGlobalInput(input, key);
  });

  // Mirror global logger entries so the D shortcut can surface them without leaving the CLI.
  React.useEffect(() => {
    const unsubscribe = logger.subscribe((entry) => {
      setDebugLogs((prev) => {
        const extras = (entry.args || []).map((arg) => {
          if (typeof arg === "string") return arg;
          if (typeof arg === "number" || typeof arg === "boolean") return String(arg);
          try {
            return JSON.stringify(arg);
          } catch (err) {
            return "[unserializable]";
          }
        }).filter(Boolean);
        const line = extras.length ? `${entry.formatted} ${extras.join(" ")}` : entry.formatted;
        const next = [...prev, line];
        return next.slice(-200);
      });
    });
    return unsubscribe;
  }, []);

  return {
    selected,
    setSelected,
    // Map messaging to creation when creating, otherwise to actions
    message: creatingContainer ? creation.message : actions.message,
    messageColor: creatingContainer ? creation.messageColor : actions.messageColor,
    showLogs: logsViewer.showLogs,
    logs: logsViewer.logs,
    exitLogs,
    creatingContainer,
    // Expose creation fields in the shape App expects
    creationStep: creation.step,
    imageNameInput: creation.imageName,
    containerNameInput: creation.containerName,
    portInput: creation.portInput,
    envInput: creation.envInput,
    creation,
    actions,
    logsViewer,
    confirmErase,
    showDebugLogs,
    debugLogs,
  };
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-index.html">index</a></li></ul><h3>Global</h3><ul><li><a href="global.html#EXIT_DELAY">EXIT_DELAY</a></li><li><a href="global.html#LOG_LEVELS">LOG_LEVELS</a></li><li><a href="global.html#MESSAGE_TIMEOUTS">MESSAGE_TIMEOUTS</a></li><li><a href="global.html#PromptField">PromptField</a></li><li><a href="global.html#PromptMessage">PromptMessage</a></li><li><a href="global.html#REFRESH_INTERVALS">REFRESH_INTERVALS</a></li><li><a href="global.html#TIMEOUTS">TIMEOUTS</a></li><li><a href="global.html#VERSION">VERSION</a></li><li><a href="global.html#colorize">colorize</a></li><li><a href="global.html#createContainer">createContainer</a></li><li><a href="global.html#docker">docker</a></li><li><a href="global.html#exitWithMessage">exitWithMessage</a></li><li><a href="global.html#getContainers">getContainers</a></li><li><a href="global.html#getLogsStream">getLogsStream</a></li><li><a href="global.html#getStats">getStats</a></li><li><a href="global.html#handleAction">handleAction</a></li><li><a href="global.html#imageExists">imageExists</a></li><li><a href="global.html#logger">logger</a></li><li><a href="global.html#makeBar">makeBar</a></li><li><a href="global.html#normalizeContainerName">normalizeContainerName</a></li><li><a href="global.html#pullImage">pullImage</a></li><li><a href="global.html#removeContainer">removeContainer</a></li><li><a href="global.html#restartContainer">restartContainer</a></li><li><a href="global.html#safeCall">safeCall</a></li><li><a href="global.html#startContainer">startContainer</a></li><li><a href="global.html#stopContainer">stopContainer</a></li><li><a href="global.html#useContainerActions">useContainerActions</a></li><li><a href="global.html#useContainerCreation">useContainerCreation</a></li><li><a href="global.html#useControls">useControls</a></li><li><a href="global.html#useLogsStream">useLogsStream</a></li><li><a href="global.html#useLogsViewer">useLogsViewer</a></li><li><a href="global.html#validateEnvVars">validateEnvVars</a></li><li><a href="global.html#validatePorts">validatePorts</a></li><li><a href="global.html#withTimeout">withTimeout</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Sat Oct 18 2025 20:57:54 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
